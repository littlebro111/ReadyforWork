# 建立 TCP 连接

HTTPS 是基于 TCP 协议的，客户端先会和服务端进行三次握手建立 TCP 连接；

# 建立TLS/SSL连接

## 第一个阶段：协商加密算法阶段

1. 客户端会在第三次 TCP 握手或者在新发送的 TCP 报文段中发送一个 client hello 报文给服务端，报文段中包含 SSL 版本号、会话ID（Session id）、加密套件列表、压缩方法以及第一个随机数；

2. 服务端收到后，会发送一个 server hello 报文进行响应，报文段中包含选中的 TSL 版本和加密套件，同时也包括随机生成的第二个随机数；

    > 会话ID（Session ID）：
    >
    > 服务器将约定的Session参数存储在TLS缓存中，并生成与其对应的Session id。它与Server Hello一起发送到客户端。客户端可以写入约定的参数到此Session id，并给定到期时间。客户端将在Client Hello中包含此id。如果客户端在此到期时间之前再次连接到服务器，则服务器可以检查与Session id对应的缓存参数，并重用它们而无需完全握手。这非常有用，因为服务器和客户端都可以节省大量的计算成本。
    >
    > 在涉及亚马逊和谷歌等流量巨大的应用程序时，这种方法存在缺点。每天都有数百万人连接到服务器，服务器必须使用Session密钥保留所有Session参数的TLS缓存。这是一个巨大的开销。
    >
    > 为了解决这个问题，在扩展包里加入了Session Tickets, 在这里，客户端可以在client hello中指定它是否支持Session Ticket。然后，服务器将创建一个新的会话票证(Session Ticket)，并使用只有服务器知道的经过私钥加密的Session参数。它将存储在客户端上，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。
    >
    > 此数据可以作为名为Session Ticket的扩展包含在Client Hello中。

## 第二个阶段：证书验证阶段

服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步：

1. 证书（Certificate）：服务器将 CA 证书发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器，除了会话恢复时不需要发送该消息，其他情况都需要发送；
2. 服务器密钥交换（Server Key Exchange）（可选）：这里视密钥交换算法而定，用于传递完成密钥交换所需的一系列参数；
3. 证书请求（Certificate Request）（可选）：服务端可能会要求客户自身进行验证。
4. 服务器握手完成（Server Hello Done）：第二阶段的结束，第三阶段开始的信号

**CA 证书中包含：**

* 服务端的公钥；
* 证书发行者（CA）对证书的数字签名；
* 证书所用的签名算法；
* 证书发布机构、有效期、所有者的信息等其他信息；

**数字签名的制作过程：**

- 先使用 CA 证书签名算法对证书内容（待签名证书内容）进行 hash；
- 再对 hash 后的值用 CA 自己的私钥加密，得到数字签名；

**浏览器验证过程：**

拿到 CA 证书后，得到证书内容、证书签名算法和数字签名。由于 CA （证书颁发机构）比较权威，所以很多浏览器会内置包含其公钥的证书，称之为根证书。然后就可以使用根证书来验证其颁发证书的合法性。

* 先用 CA 机构的公钥对数字签名解密；
* 再用证书里的签名算法对证书内容进行 hash；
* 比较解密后的数字签名和对证书内容 hash 后的哈希值，相等则表明证书可信，否则即不可信，拒绝对该服务器的访问。

## 第三个阶段：建立会话密钥阶段

客户机启动SSL握手第3阶段，是本阶段所有消息的唯一发送方，服务器是所有消息的唯一接收方。该阶段分为3步：

1. 证书（Certificate）（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证；
2. 客户机密钥交换（Client key exchange）：客户端随机生成第三个随机数，也称为预主密钥，并使用服务器的公钥进行加密；
3. 证书验证（Certificate Verify）（可选）：对预备秘密和随机数进行签名，证明拥有（a）证书的公钥。只有在客户端发送了自己证书到服务器端，这个消息才需要发送。其中包含一个签名，对从第一条消息以来的所有握手消息的 HMAC 值（用 master_secret）进行签名；

客户端会利用第一、第二和第三个随机数合并生成一个会话密钥，作为之后对称加密的密钥。

服务端收到客户端的报文后，会使用私钥进行解密，这样就得到了预主密钥，而且只有客户端和服务端知道这个预主密钥，没有其他人知道；然后，服务端会使用第一随机数，第二随机数和预主密钥也生成一个会话密钥，这个会话密钥和客户端生成的会话密钥是一样的；

至此TSL连接建立完成，可以开始传输数据，并且使用同一个密钥来加解密（即对称加密）。

## 第四个阶段：完成阶段

客户机启动SSL握手第4阶段，使服务器结束。该阶段分为4步，前2个消息来自客户机，后2个消息来自服务器。

建立起一个安全的连接，客户端发送一个 Change Cipher Spec 消息，并且把协商得到的 CipherSuite 拷贝到当前连接的状态之中。然后，客户端用新的算法、密钥参数发送一个 Finished 消息，这条消息可以检查密钥交换和认证过程是否已经成功。其中包括一个校验值，对客户端整个握手过程的消息进行校验。服务器同样发送 Change Cipher Spec 消息和 Finished 消息。握手过程完成，客户端和服务器可以交换应用层数据进行通信。

Change Cipher Spec：这是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了；

Finish：使用 HMAC 算法计算之前所有握手信息的 hash 值，加密后发送，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。

# 参考资料

[1] [SSL协议原理详解](https://blog.csdn.net/qq_38265137/article/details/90112705)

[2] [通俗易懂的TCP，SSL以及HTTPS的连接建立过程详解](https://blog.csdn.net/yxg520s/article/details/122004032)