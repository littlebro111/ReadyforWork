# InnoDB的MVCC

MVCC，即多版本并发控制，是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。

在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能，还可以解决脏读、幻读、不可重复读等事务隔离问题，但不能解决更新丢失问题。（MVCC不解决写-写冲突，需要用乐观锁或悲观锁解决）

实现原理主要是依赖记录中的3个隐式字段、undo日志和Read View。

**3个隐式字段：**

- DB_TRX_ID：
    6 byte，最近修改(修改/插入)事务 ID：记录创建这条记录/最后一次修改该记录的事务 ID

- DB_ROLL_PTR：
    7 byte，回滚指针，指向undo log的指针，指向这条记录的上一个版本（存储于 rollback segment 里）

- DB_ROW_ID：
    6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以DB_ROW_ID产生一个聚簇索引

**基于undo log的版本链：** 每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。

**Read View：** 当事务A进行对某条记录进行快照读的时候，数据库为该行数据生成一个Read View，记录当前时刻数据库中活跃的事务ID，然后将该条记录隐藏列中的DB_TRX_ID与这些事务ID进行比对，如果DB_TRX_ID比所有活跃事务的ID都小，则说明当前事务可以看到这条记录；如果DB_TRX_ID比快照生成时刻系统中所有已生成的事务ID都大，那就说明这条记录对当前事务不可见；如果前两者都不是，那就比对DB_TRX_ID是否在当前活跃事务ID中出现，如果未出现，就说明该条记录的修改结果对当前事务可见；若出现了，则说明这条记录现版本数据对当前事务是不可见的，需要继续查询该记录的上一个版本。以此类推。

需要注意的是：

* 在 RR 级别下的某个事务的对某条记录的第一次快照读会创建一个快照及 Read View, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个 Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个 Read View，所以对之后的修改不可见；
* 即 RR 级别下，快照读生成 Read View 时，Read View 会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见
* 而在 RC 级别下的，事务中，每次快照读都会新生成一个快照和 Read View , 这就是我们在 RC 级别下的事务中可以看到别的事务提交的更新的原因

> 参考资料：https://blog.csdn.net/SnailMann/article/details/94724197