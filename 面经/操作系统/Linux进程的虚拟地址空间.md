# 1. 虚拟地址空间的基本概念

**（1）什么是虚拟地址空间？**

- 每个进程都有一个独立的虚拟地址空间，范围通常从 `0x00000000` 到 `0xFFFFFFFF`（32 位系统）或 `0x0000000000000000` 到 `0xFFFFFFFFFFFFFFFF`（64 位系统）。
- 虚拟地址空间是逻辑上的内存地址，与实际的物理内存地址无关。

**（2）虚拟地址空间的作用**

- **隔离性** ：每个进程的虚拟地址空间相互独立，避免进程间直接访问彼此的内存。
- **安全性** ：防止恶意程序直接访问操作系统或其他进程的内存。
- **灵活性** ：支持内存分页、共享内存、内存映射等高级功能。

---

# 2. 虚拟地址空间的布局

在 Linux 中，虚拟地址空间的布局因架构（32 位或 64 位）而异。以下以 32 位系统为例说明典型的虚拟地址空间从低地址到高地址的布局：

**（1）用户空间（User Space）**

- 占据虚拟地址空间的低地址部分（通常是 `0x00000000` 到 `0xBFFFFFFF`）。
- 每个进程都有自己独立的用户空间，包含以下区域：
    1. **代码段（Text Segment）** ：
        - 存储程序的可执行指令。
        - 通常是只读的，防止意外修改。
    2. **数据段（Data Segment）** ：
        - 包括初始化的全局变量和静态变量。
    3. **BSS 段（Block Started by Symbol）** ：
        - 存储未初始化的全局变量和静态变量。
        - 在程序加载时会被初始化为零。
    4. **堆（Heap）** ：
        - 动态分配的内存区域（通过 `malloc` 或 `new` 分配）。
        - 堆向高地址方向增长。
    5. **栈（Stack）** ：
        - 存储函数调用的局部变量、返回地址等。
        - 栈向低地址方向增长。
    6. **内存映射区（Memory Mapping Area）** ：
        - 用于动态库加载、文件映射（如 `mmap`）等。
        - 位于堆和栈之间。

**（2）内核空间（Kernel Space）**

- 占据虚拟地址空间的高地址部分（通常是 `0xC0000000` 到 `0xFFFFFFFF`）。
- 所有进程共享内核空间，用于运行操作系统内核代码和管理硬件资源。
- 用户程序无法直接访问内核空间，必须通过系统调用进入内核模式。