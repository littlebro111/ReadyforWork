# 线程间通信

线程间无需特别的手段进行通信，因为线程间可以共享一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段等，所以线程之间可以方便、快速地共享信息。只需要将数据复制到共享（全局或堆）变量中即可。（定义全局变量时最好使用volatile来定义，以防编译器对此变量进行优化）

> volatile 意思是易变的，是一种类型修饰符，在C/C++中用来阻止[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)因误认某段代码无法被代码本身所改变，而造成的过度优化。编译器每次读取 volatile 定义的变量时，都从内存地址处重新取值。

# 线程间同步

线程间同步的方法有：信号、锁机制（包括互斥锁、条件变量、读写锁和自旋锁）、信号量

**互斥锁**确保同一时间只能有一个线程访问共享资源，当锁被占用时试图对其加锁的线程都进入阻塞状态（释放 CPU 资源使其由运行状态进入等待状态），当锁释放时哪个等待线程能获得该锁取决于内核的调度。 

**条件变量**可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。 

**读写锁**当以写模式加锁而处于写状态时任何试图加锁的线程（不论是读或写）都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。 

**自旋锁**上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对 CPU 的霸占会导致 CPU 资源的浪费。 所以自旋锁适用于并行结构（多个处理器）或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

**信号量**实际上是一个整数计数器，是用来调协进程对共享资源的访问的，提供两个原子操作：P操作和V操作。