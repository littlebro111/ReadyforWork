# Python的GIL

GIL全称Global Interpreter Lock，又叫全局解释器锁，每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程在运行，目的是解决多线程同时竞争程序中的全局变量而出现的线程安全问题。

GIL并不是Python语言的特性，它仅仅是由于历史的原因在CPython解释器中难以移除，因为python语言运行环境大部分默认在CPython解释器中。

Python语言中的多线程其实是假的多线程，它只会在一个CPU上运行。由于GIL的存在，当在Python上开启多个线程时，每个单独线程会争抢GIL锁，只有在竞争到GIL后才会运行，这会造成当某一个线程没有抢到锁的时候会让cpu等待，导致在多核CPU上，Python的多线程实际是串行执行的，并不会同一时间多个线程分布在多个CPU上运行。

Python的多线程在多核CPU上，只对于I/O密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。

**解决GIL问题的方案：**

1. 把多线程的部分使用其它语言去实现，例如C，Java

2. 使用其它的python解释器，如jpython或者IronPython

3. 用multiprocess替代Thread

> multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。
>
> 当然multiprocess也不是万能良药，它的引入会增加程序实现时线程间数据通讯和同步的困难。

**线程释放GIL锁的情况：**

1. 在I/O操作等可能会引起阻塞的系统调用之前，可以暂时释放GIL锁，但在执行完毕后，必须重新获取GIL。

2. Python 3.x使用计时器，执行时间达到阈值后，当前线程释放GIL；Python 2.x则是当tickets计数达到100时，当前线程释放GIL。