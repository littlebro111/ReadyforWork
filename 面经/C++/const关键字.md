# const关键字的作用

* const类型定义：指明变量或对象的值是不能被更新，引入目的是为了取代预编译指令，且便于进行类型检查；
* 可以保护被修饰的东西，防止意外的修改，增强程序的健壮性；
* 可以节省空间，避免不必要的内存分配，编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高；

# const修饰指针

## 常量指针（底层const）

形式：`const 数据类型 *指针变量 = 变量名 或者 数据类型 const *指针变量 = 变量名`

特点：指针所指向的内容是常量不可变，不能通过指针来修改变量的值。但是可以不通过指针改变指向的值，如情况一所示 。另外指针也可以指向其他地址，如情况二所示。

```c++
int temp = 10;
const int *a = &temp; // 形式1
int const *b = &temp; // 形式2

// 情况一
*a = 9 // 错误
temp = 9; // 正确

// 情况二
int c = 0;
const int *b = &c; // 正确
```

## 指针常量（顶层const）

形式： 数据类型 * const 指针变量 = 变量名

特点：指针本身是常量不可变，指针的指向的地址不能改变，不能给该指针赋予其他地址。而且指针常量在声明时必须初始化。但同时指针所指向的地址的内容可以修改。

```c++
int temp1 = 10;
int temp2 = 20;
int *const p = &temp1; // 指针常量

p = &temp2; // 错误
*p = 30; // 正确
```

## 常指针常量

形式：const 数据类型 * const 指针变量 = 变量名 或者 数据类型 const * const 指针变量 = 变量名

特点：上述两者的综合，既不能通过指针改变指向的值，指针指向的地址也不能改变。

```c++
int temp = 10;
const int * const a = &temp; // 形式1
int const * const b = &temp; // 形式2
```



**区分顶层const和底层const的原因？**

1. 底层const的指针不能赋给非底层const。

2. 强制类型转换函数const_cast只能将底层const指针改变为普通指针，其余指针不行。

# 函数中使用const

## const修饰函数参数

用const修饰函数参数表示在该函数中不会改变参数；

当用实参初始化形参时会忽略掉形参的顶层const，即实参值本身是不是const无所谓；

但如果形参不是顶层const，那么实参也不能是顶层const，也就是说如果形参是可变的，传进来的值必须可变才行；

参数为引用时，使用常量引用可以在增加效率的同时防止对参数进行修改

## const 修饰函数返回值

如果函数返回值采用“值传递”方式，那么由于函数会把返回值复制到外部临时的存储单元中，而那个临时存储单元确实是个const int，所以加const修饰没有任何价值，即`const int func(int a);`等同于`int func(int a);`。

如果函数返回值采用“指针传递”方式，那么返回值可以是指针常量，也可以是常量指针。

* 如果返回值是指针常量，那么该const修饰同样是毫无意义的；
* 如果返回值是常量指针，这时就有意义了，会返回一个常量指针。

通常情况下，不使用const修饰函数的返回值类型为某个对象或某个对象的引用。因为如果使用const修饰函数的返回值类型为某个对象（如：const A test = A实例）或某个对象的引用（const A &test = A实例） ，则返回值也将具有const属性，那么返回实例就只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这种情况很少遇到。

# 类中使用CONST

## const修饰成员变量

表示成员变量不能被修改，同时只能在初始化列表中赋值

## const修饰成员函数

const成员函数就是将const放在成员函数的末尾，且声明和定义中都要加。表示该函数不会修改类的成员变量，也不能调用类中任何非const成员函数。

## const修饰类对象

用const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改，而且也不能调用该对象的任何非const成员函数。