# 一、什么是STL

STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的 C++ 程序库。它被容纳于 C++ 标准程序库（C++ Standard Library）中，是 ANSI/ISO C++ 标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大 C++ 程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。


STL 的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于 STL 的 sort() 函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组；


STL 另一个重要特性是它不是面向对象的。为了具有足够通用性，STL 主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP 的三个要素。你在 STL 中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得 STL 的组件具有广泛通用性的底层特征。另外，由于 STL 是基于模板，内联函数的使用使得生成的代码短小高效；


从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与 OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术；

从实现层次看，整个 STL 是以一种类型参数化的方式实现的，这种方式基于一个在早先 C++ 标准中没有出现的语言特性——模板（template）。

# 二、STL内容介绍

STL中六大组件：

* **容器（Container）** ：是一种数据结构，如：vector、deque、list、set、map 等，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；
* **迭代器（Iterator）** ：提供了访问容器中对象的方法。例如，可以使用一对迭代器指定 list 或 vector 中的一定范围的对象。迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。但是，迭代器也可以是那些定义了 operator*() 以及其他类似于指针的操作符地方法的类对象；
* **算法（Algorithm）** ：是用来操作容器中的数据的模板函数。例如，STL 用 sort() 来对一个 vector 中的数据进行排序，用 find() 来搜索一个 list 中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；
* **仿函数（Functor）**
* **适配器（Adaptor）**
* **分配器（allocator）**

## 容器

STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包（string_package）等等。

1. **序列式容器（Sequence containers）** ：每个元素都有固定位置，其位置只取决于插入时机和地点，和元素值无关，包括：vector、deque、list；

    * **vector：** 将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；

    * **deque：** 是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；

    * **list：** 双向链表，不提供随机存取（按顺序走到需存取的元素，$O(n)$），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；

2. **关联式容器（Associated containers）** ：元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。

    * **set/multiset：** 内部的元素依据其值自动排序，set 内的相同数值的元素只能出现一次，multisets 内可包含多个数值相同的元素，内部由红黑树实现，便于查找；

    * **map/multimap：** map 的元素是成对的键值/实值，内部的元素依据其值自动排序，map 内的相同数值的元素只能出现一次，multimaps 内可包含多个数值相同的元素，内部由红黑树实现，便于查找；

容器类自动申请和释放内存，无需 new 和 delete 操作。

## 迭代器

Iterator（迭代器）模式又称 Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator 模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由 iterator 提供的方法）访问聚合对象中的各个元素。

迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了 *，++，==，!=，=运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator 和 const_reverse_iterator。

## 算法

函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而 C++ 通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL 就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。

STL 提供了大约 100 个实现算法的模版函数，比如算法 for_each 将为指定序列中的每一个元素调用指定的函数，stable_sort 以你所指定的规则对序列进行稳定性排序等等。只要我们熟悉了 STL 之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。

算法部分主要由头文件 \<algorithm\>，\<numeric\> 和 \<functional\>组成。

* \<algorithm\>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。
* \<numeric\>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。
* \<functional\>中则定义了一些模板类，用以声明函数对象。

STL 中算法大致分为四类：

* 非可变序列算法：指不直接修改其所操作的容器内容的算法。
* 可变序列算法：指可以修改它们所操作的容器内容的算法。
* 排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。
* 数值算法：对容器内容进行数值计算。

## 仿函数

仿函数（functor）就是使一个类的使用看上去象一个函数。其实现就是类中实现一个 operator()，这个类就有了类似函数的行为，就是一个仿函数类了。

有些功能的代码，会在不同的成员函数中用到，想复用这些代码，一般有以下两种方式：

1. 公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。

2. 仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个 operator()，在类实例化时，就将要用的，非参数的元素传入类中。

在 C++ 里，通常是通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。

```c++
#include <iostream>
#include <algorithm>
 
using namespace std;
template<typename T>
class display
{
public:
	void operator()(const T &x)
	{
		cout << x << " ";
	}
};
int main()
{
	int ia[] = { 1,2,3,4,5 };
	for_each(ia, ia + 5, display<int>());
	system("pause");
	return 0;
}
```

要使用STL内建的仿函数，必须包含 \<functional\> 头文件。而头文件中包含的仿函数分类包括

1. 算术类仿函数
    * 加：plus\<T\>
    * 减：minus\<T\>
    * 乘：multiplies\<T\>
    * 除：divides\<T\>
    * 模取：modulus\<T\>
    * 否定：negate\<T\>

2. 关系运算类仿函数
    * 等于：equal_to\<T\>
    * 不等于：not_equal_to\<T\>
    * 大于：greater\<T\>
    * 大于等于：greater_equal\<T\>
    * 小于：less\<T\>
    * 小于等于：less_equal\<T\>
3. 逻辑运算仿函数
    * 逻辑与：logical_and\<T\>
    * 逻辑或：logical_or\<T\>
    * 逻辑否：logical_no\<T\>

除了使用STL内建的仿函数，还可使用自定义的仿函数。          

## 容器适配器

标准库提供了三种顺序容器适配器：queue（FIFO队列）、priority_queue（优先级队列）、stack（栈）。

适配器是使一种事物的行为类似于另外一种事物行为的一种机制，适配器对容器进行包装，使其表现出另外一种行为。例如，`stack<int, vector<int> >`实现了栈的功能，但其内部使用顺序容器 vector\<int\> 来存储数据。（相当于是 vector\<int\> 表现出了栈的行为）。

要使用适配器，需要加入一下头文件：

```c++
#include <stack>    //stack
#include <queue>    //queue、priority_queue
```

|      种类      | 默认顺序容器 |    可用顺序容器     |               说明               |
| :------------: | :----------: | :-----------------: | :------------------------------: |
|     stack      |    deque     | vector、list、deque |                                  |
|     queue      |    deque     |     list、deque     | 基础容器必须提供push_front()运算 |
| priority_queue |    vector    |    vector、deque    |   基础容器必须提供随机访问功能   |

# 常用容器实现

## vector实现

Vector是一个类，它里面有三个指针myfirst,mylast,myend.分别表示首地址，元素容量地址，容器容量地址。通过这三个指针分别表示容器的所有操作。

**vector的扩容机制**

Vector扩容就是重新申请一段更长的连续内存空间并把以前的数据移动过去，释放以前的内存空间。以前的迭代器都会失效。扩容在Linux上会扩两倍的容量，在windows上会扩容1.5倍。

## set/map实现

|        集合        | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 |  查询效率   |  增删效率   |
| :----------------: | :------: | :------: | :--------------: | :----------: | :---------: | :---------: |
|      std::set      |  红黑树  |   有序   |        否        |      否      | $O(log_2n)$ | $O(log_2n)$ |
|   std::multiset    |  红黑树  |   有序   |        是        |      否      | $O(log_2n)$ | $O(log_2n)$ |
| std::unordered_set |  哈希表  |   无序   |        否        |      否      |   $O(1)$    |   $O(1)$    |

|        映射        | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 |  查询效率   |  增删效率   |
| :----------------: | :------: | :------: | :--------------: | :----------: | :---------: | :---------: |
|      std::map      |  红黑树  | key有序  |   key不可重复    | key不可修改  | $O(log_2n)$ | $O(log_2n)$ |
|   std::multimap    |  红黑树  | key有序  |    key可重复     | key不可修改  | $O(log_2n)$ | $O(log_2n)$ |
| std::unordered_map |  哈希表  | key无序  |   key不可重复    | key不可修改  |   $O(1)$    |   $O(1)$    |

> 参考资料：[C++中STL用法超详细总结](https://blog.csdn.net/u010183728/article/details/81913729)